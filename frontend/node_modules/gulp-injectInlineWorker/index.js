// Gulp plugin to convert string to BLOB URI for webworker inlining
// Author: 
//   Thibault Piront
//   Osimis SA.

// Usage:
// 
// In main thread js files: 
//   In front of the path string, put:
//       /* @inline-worker: */
//   For instance: 
//       var path = /* @inline-worker: */ '/app/image/image-parser.worker/main.js';
//   You can free created ObjectUrls like this:
//       // Free inline-worker's ObjectUrl
//       if (typeof pathURL !== 'string') URL.revokeObjectUrl(path);
// 
// In worker thread js files:
//   you can use inline with importScripts(...), eg:
//       /* @inline: */ importScripts('/app/image/image-parser.worker/klvreader.class.js');
// 
// For path string,
//   - Do not use double quote (use single ones) 
//   - Do not use variables
//   - Do not use escaped quote
//   - Do not concatenate strings
//   -> Only put clean strings
// 
// In Gulp, eg:
//   gulp
//     .src('mainThreadFile.js')
//     .pipe($.injectInlineWorker({
//         pathRouter: {
//             '/app/': './src/app/',
//             '/bower_components/': './bower_components/'
//         }
//     }))
//     .pipe(gulp.dest('mainThreadFile.injected.js');

var fs = require('fs');
var path = require('path');
var through = require('through2');
var gutil = require('gulp-util');
var PluginError = gutil.PluginError;
var $ = require('gulp-load-plugins')({lazy: true});

const PLUGIN_NAME = 'gulp-injectInlineWorker';

/**
 * Log a message or series of messages using chalk's blue color.
 * Can pass in a string, object or array.
 */
function log(msg) {
    if (typeof(msg) === 'object') {
        for (var item in msg) {
            if (msg.hasOwnProperty(item)) {
                $.util.log($.util.colors.blue(msg[item]));
            }
        }
    } else {
        $.util.log($.util.colors.blue(msg));
    }
}

var injectInlineWorker = function(opts) {
    log("--- injecting inline worker ---");
    return through.obj(function(file, encoding, callback) {
        // Ignore empty files
        if (file.isNull()) {
            return callback(null, file);
        }

        // No stream support, only files.
        if (file.isStream()) {
            this.emit('error', new PluginError('gulp-injectInlineWorker', 'Streams not supported!'));
            return callback('Streaming not supported', file);
        }
        if (!file.isBuffer()) {
            this.emit('error', new PluginError(PLUGIN_NAME, 'Unknown stream type!'));
            return;
        }

        // Ignore non js files
        if (!file.relative.endsWith('.js')) {
            return callback(null, file);
        }

        // Process file if everything seems ok
        var input = file.contents.toString();
        var workerPathRegex = /(?:\/\*\s*@inline-worker:\s*\*\/)\s'([^']*)'/g;
        var importScriptsRegex = /(?:\/\*\s@inline:\s\*\/)\simportScripts\('([^']*)'\)/g;

        // Inline marked worker path with the path's file content
        var output = input.replace(workerPathRegex, function(match, p1, offset, string) {
            // Load worker script content
            var workerPath = _getRealPath(p1, opts && opts.pathRouter);
            var workerContent = fs.readFileSync(workerPath, 'utf8');

            // Inline imported scripts
            workerContent = workerContent.replace(importScriptsRegex, function(match, p1, offset, string) {
                // Load importScript content
                var importScriptPath = _getRealPath(p1, opts && opts.pathRouter);
                var importScriptContent = fs.readFileSync(importScriptPath, 'utf8');

                return importScriptContent;
            });

            // Escape worker content - http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4
            workerContent = workerContent.replace(/\\/g, "\\\\");
            workerContent = workerContent.replace(/'/g, "\\\'");
            workerContent = workerContent.replace(/\r/g, "\\r");
            workerContent = workerContent.replace(/\n/g, "\\n");
            workerContent = workerContent.replace(/\u2028/g, "\\u2028");
            workerContent = workerContent.replace(/\u2029/g, "\\u2029");

            // Wrap worker content with blob string creator. We need to store
            // the blob in a global context since IE11 garbage collector is
            // broken (it flushes BLOB directly when created within ObjectURL).
            // see
            // `https://connect.microsoft.com/IE/feedback/details/816540/ie-destroying-blob-types-incorrectly`.
            // var wrappedWorkerContent = '(URL.createObjectURL((((window||self).__workerBlobs = (window||self).__workerBlobs || []) && ((window||self).__workerBlobs[(window||self).__workerBlobs.push(new Blob([\'('+workerContent+')()\'], {type: \'application/javascript\'}))-1]))))';
            // ...
            // Also, this wont work with IE10 & IE11.. We can't have string as
            // web worker...
            // see `https://readable-email.org/list/public-webapps/topic/ie-security-error-with-new-worker-url-createobjecturl-new-blob-workerjs-type-text-javascript`
            // so let's go back to our IE10/IE11 uncompatible way.
            var wrappedWorkerContent = '(URL.createObjectURL(new Blob([\''+workerContent+'\'], {type: \'application/javascript\'})))';

            // Convert path to blob
            return wrappedWorkerContent;
        });

        file.contents = new Buffer(output);

        return callback(null, file);
    });
}

// Get a relative path using the pathRouter option
function _getRealPath(pathFromCode, router) {
    if (!router) {
        return path.normalize(pathFromCode);
    }

    var realPath = pathFromCode;

    // Replace code path to real relative path using the router in option
    for (var codePath in router) {
        realPath = realPath.replace(new RegExp('^'+codePath), router[codePath]);
    }

    // Convert os specific separators
    realPath = path.normalize(realPath);

    return realPath;
}

module.exports = injectInlineWorker;
